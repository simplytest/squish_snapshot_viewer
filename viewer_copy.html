<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Squish Snapshot Viewer</title>
<style>
/* squish_xml_viewer.css - Styles for the XML viewer */

*,
*::before,
*::after {
    box-sizing: border-box;
}

body {
    font-family: Arial, Helvetica, sans-serif; 
    margin: 0; 
    padding: 0;
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.header {
    padding: 10px; 
    background: #5dade2; /* Light Blue */
    color: white; 
    display: flex; 
    align-items: center; 
    gap: 15px;
    flex-shrink: 0;
}

.header h1 {
    margin: 0; 
    font-size: 18px; 
    color: white;
}

.header-search-group {
    display: flex; 
    align-items: center; 
    gap: 10px;
}

.header-search-group label {
    font-size: 12px; 
    color: #ecf0f1; 
    white-space: nowrap;
}

.header-search-group input, .header-search-group select {
    padding: 4px; 
    border: none; 
    border-radius: 3px; 
    font-size: 12px;
}

.header-search-group .search-container {
    position: relative;
}

.header .clear-btn {
    color: #666; 
    background: white;
}

.main-container {
    display: flex;
    flex: 1;
    min-height: 0;
}

.file-sidebar {
    width: 350px; /* Increased width */
    border-right: 1px solid #ddd;
    display: flex;
    flex-direction: column;
}

.file-sidebar-header {
    padding: 10px;
    border-bottom: 1px solid #ddd;
    background: #f9f9f9;
}

#folderSelectBtn {
    width: 100%;
    padding: 8px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
}
#folderSelectBtn:hover {
    background-color: #2980b9;
}

.file-list {
    list-style: none;
    padding: 10px;
    margin: 0;
    overflow-y: auto;
    flex: 1;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-content: flex-start;
}

.file-list-item {
    flex-basis: calc(50% - 10px);
    flex-grow: 1;
    margin: 5px;
    padding: 10px;
    cursor: pointer;
    border: 1px solid #ccc;
    border-radius: 5px;
    font-size: 14px;
    background: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    word-wrap: break-word;
    transition: all 0.2s ease;
}

.file-list-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.file-list-item.selected {
    background: #aed6f1; /* Lighter Blue */
    font-weight: bold;
    border-color: #5dade2; /* Light Blue */
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.viewer-container {
    display: flex;
    flex: 1;
    height: 100%;
}

#initial-message {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #888;
    font-size: 18px;
}

.container {
    display: none; 
    flex: 1;
    height: 100%;
}

.sidebar {
    width: 360px; 
    border-right: 1px solid #ddd; 
    display: flex; 
    flex-direction: column;
    height: 100%;
}

.sidebar-content {
    flex: 1; 
    padding: 10px; 
    overflow: auto;
}

.right-panel {
    flex: 1; 
    display: flex; 
    flex-direction: column;
    height: 100%;
}

.screenshot-panel {
    height: 40%;
    border-bottom: 1px solid #ddd; 
    flex-shrink: 0;
    position: relative;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
}

.screenshot-container {
    position: relative;
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    overflow: hidden;
}

.screenshot {
    max-width: 100%; 
    max-height: 100%;
    border: 1px solid #ccc; 
    object-fit: contain;
}

.properties-panel {
    flex: 1; 
    display: flex; 
    flex-direction: column; 
    min-height: 0;
}

.properties-content {
    flex: 1; 
    padding: 10px; 
    overflow: auto; 
    min-height: 0;
}

.panel-header {
    padding: 10px; 
    border-bottom: 1px solid #eee; 
    background: #f9f9f9;
    display: flex;
    align-items: baseline;
    gap: 10px;
    flex-shrink: 0;
}

.panel-header h3 {
    margin: 0;
    font-size: 16px;
    color: #333;
}

#screenshot-path {
    font-size: 12px;
    margin: 0;
    color: #666;
}

/* Tree View Styles */
.tree {
    list-style: none;
    padding: 0;
    margin: 0;
}

.tree ul {
    list-style-type: none;
    padding-left: 20px;
}

.tree li {
    margin: 5px 0;
}

.node {
    cursor: pointer;
    padding: 2px 5px;
    border-radius: 3px;
    display: inline-block;
}

.node:hover {
    background: #eaf2f8; /* Very Light Blue */
}

.node.selected {
    background: #aed6f1; /* Lighter Blue */
}

.props {
    white-space: pre-wrap; 
    font-family: monospace; 
    background: #f7f7f7; 
    padding: 8px; 
    border-radius: 4px; 
    max-height: 300px; 
    overflow: auto;
}

.props-table {
    width: 100%; 
    border-collapse: collapse; 
    font-size: 12px;
}

.props-table th, .props-table td {
    border: 1px solid #ddd; 
    padding: 4px 8px; 
    text-align: left;
    position: relative;
}

.props-table th {
    background: #eaf2f8; /* Very Light Blue */
    font-weight: bold;
    cursor: pointer;
    position: relative;
}

.props-table th.sort-asc::after {
    content: ' \25B2';
    color: #3498db;
}

.props-table th.sort-desc::after {
    content: ' \25BC';
    color: #3498db;
}

.props-table tr:nth-child(even) {
    background: #f9f9f9;
}

.props-table td:first-child {
    font-weight: bold; 
    color: #666; 
    max-width: 150px; 
    word-break: break-word;
}

.props-table td:last-child {
    font-family: monospace; 
    max-width: 200px; 
    word-break: break-all;
}

.props-table .group-header {
    background: #d4e6f1; /* Light Blue */
}

.props-table .group-header td {
    font-weight: bold; 
    color: #2c3e50; 
    border-bottom: 2px solid #5dade2; /* Light Blue */
}

.props-table .group-item {
    background: #f8fcff;
}

.props-table .group-item td:first-child {
    padding-left: 20px; 
    font-style: italic; 
    color: #34495e;
}

.props-table tr:hover {
    background: #eaf2f8; /* Very Light Blue */
    cursor: pointer;
}

.props-table tr.selected {
    background: #d4e6f1; /* Light Blue */
}

.props-table tr.selected td {
    background: transparent;
}

.context-menu {
    position: absolute; 
    background: white; 
    border: 1px solid #ccc; 
    border-radius: 4px; 
    padding: 5px 0; 
    box-shadow: 2px 2px 10px rgba(0,0,0,0.3); 
    z-index: 1000; 
    display: none;
}

.context-menu-item {
    padding: 5px 15px; 
    cursor: pointer;
}

.context-menu-item:hover {
    background: #f0f0f0;
}

.search-container {
    position: relative; 
    width: 100%;
}

.search-container input {
    width: 100%; 
    box-sizing: border-box;
}

.clear-btn {
    position: absolute; 
    right: 5px; 
    top: 50%; 
    transform: translateY(-50%); 
    background: none; 
    border: none; 
    font-size: 16px; 
    cursor: pointer; 
    color: #666; 
    padding: 0; 
    width: 20px; 
    height: 20px; 
    display: none;
}

.clear-btn:hover {
    color: #333; 
    background: #f0f0f0; 
    border-radius: 50%;
}

.search-container input:not(:placeholder-shown) + .clear-btn {
    display: block;
}

.element-overlay {
    position: absolute;
    border: 3px solid #5dade2; /* Light Blue */
    background: rgba(93, 173, 226, 0.1); /* Light Blue transparent */
    pointer-events: none;
    z-index: 10;
    animation: pulsate 1s infinite;
}

@keyframes pulsate {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.02);
    }
    100% {
        transform: scale(1);
    }
}

mark {
    background-color: yellow;
    padding: 0;
}

.toggle {
    cursor: pointer;
    margin-right: 5px;
    font-weight: bold;
    display: inline-block;
    width: 15px;
    text-align: center;
    user-select: none;
}

.nested {
}

.nested.collapsed {
    display: none;
}

.node.highlight {
    background-color: #f0ad4e;
}

#clearHighlight {
    padding: 2px 8px;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    color: #333;
    margin-left: 10px;
}

#clearHighlight:hover {
    background-color: #e0e0e0;
}

.context-menu-item.disabled-menu-item {
    color: #aaa;
    cursor: not-allowed;
    background-color: #f0f0f0;
}

.context-menu-item.disabled-menu-item:hover {
    background: #f0f0f0;
}
</style>
</head>
<body>

<div class="header">
  <h1>Squish Snapshot Viewer</h1>
  <div class="header-search-group">
    <label>Tree:</label>
    <div class="search-container">
      <input id="treeSearch" placeholder="Search tree..." style="width:150px; padding:4px; padding-right:25px;">
      <button id="clearTreeSearch" class="clear-btn" onclick="clearTreeSearch()" title="Clear search">&times;</button>
    </div>
  </div>
  <div class="header-search-group">
    <label>Properties:</label>
    <div class="search-container">
      <input id="propsSearch" placeholder="Search properties..." style="width:150px; padding:4px; padding-right:25px;">
      <button id="clearPropsSearch" class="clear-btn" onclick="clearPropsSearch()" title="Clear search">&times;</button>
    </div>
  </div>
  <div class="header-search-group">
    <label>Prop Values:</label>
    <div class="search-container">
      <input id="propertyValueSearch" placeholder="Search by property value..." style="width:150px; padding:4px; padding-right:25px;">
      <button id="clearPropertyValueSearch" class="clear-btn" onclick="clearPropertyValueSearch()" title="Clear search">&times;</button>
    </div>
  </div>
  <div class="header-search-group">
    <label>Sort by:</label>
    <select id="sortColumn" onchange="refreshProperties()" style="padding:4px;">
      <option value="Property">Property</option>
      <option value="Value">Value</option>
    </select>
    <select id="sortOrder" onchange="refreshProperties()" style="padding:4px;">
      <option value="asc">Ascending</option>
      <option value="desc">Descending</option>
      <option value="none">None</option>
    </select>
  </div>
  <div class="header-search-group">
    <input type="checkbox" id="showOnlyMatches">
    <label for="showOnlyMatches" style="color: white; font-size: 12px;">Show only matching elements</label>
  </div>
</div>

<div class="main-container">
    <div class="file-sidebar">
        <div class="file-sidebar-header">
            <input type="file" id="folderInput" webkitdirectory style="display: none;" />
            <button id="folderSelectBtn">Select Snapshot Folder</button>
        </div>
        <ul class="file-list" id="fileList"></ul>
    </div>
    <div class="viewer-container">
        <div id="initial-message">Select a folder to see snapshot files.</div>
        <div class="container" id="viewerContent">
            <div class="sidebar">
                <div class="sidebar-header panel-header">
                <h3>Object Tree</h3>
                </div>
                <div class="sidebar-content">
                <div id="treeContainer"></div>
                </div>
            </div>
            <div class="right-panel">
                <div class="screenshot-panel">
                    <div class="panel-header">
                        <h3>Squish Snapshot</h3>
                        <p id="screenshot-path" class="props"></p>
                    </div>
                    <div class="screenshot-container" id="screenshotContainer">
                    </div>
                </div>
                <div class="properties-panel">
                    <div class="properties-header panel-header">
                        <h3>Selected Node Properties</h3>
                    </div>
                    <div class="properties-content">
                        <div id="props">Click a node in the tree to see its properties here.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Context Menus -->
<div id="treeContextMenu" class="context-menu">
  <div class="context-menu-item" data-type="realname">Copy real name</div>
  <div class="context-menu-item" data-type="copy-as-object">Copy as BasePage object</div>
  <div class="context-menu-item" data-type="class">Copy class name</div>
  <div class="context-menu-item" data-type="objectName">Copy object name</div>
</div>

<div id="propsContextMenu" class="context-menu">
  <div class="context-menu-item" data-type="propValue">Copy property value</div>
  <div class="context-menu-item" data-type="propName">Copy property name</div>
</div>

<script>
// --- Start of New All-in-One Viewer Logic ---

let xmlFiles = [];
// This would be loaded from a whitelist.txt file in a real scenario.
// For this static version, it's hardcoded. A future improvement could be to select this file too.
var attributeWhitelist = ["name", "text", "title", "type", "unnamed", "visible", "windowTitle", "simplifiedType"];

document.addEventListener("DOMContentLoaded", function() {
    const folderSelectBtn = document.getElementById('folderSelectBtn');
    const folderInput = document.getElementById('folderInput');
    const fileList = document.getElementById('fileList');
    const initialMessage = document.getElementById('initial-message');
    const viewerContent = document.getElementById('viewerContent');

    folderSelectBtn.addEventListener('click', () => folderInput.click());
    folderInput.addEventListener('change', handleFolderSelection);

    function handleFolderSelection(event) {
        const files = event.target.files;
        xmlFiles = Array.from(files).filter(file => file.name.endsWith('.xml'));
        
        fileList.innerHTML = ''; // Clear previous list
        
        if (xmlFiles.length > 0) {
            initialMessage.textContent = 'Select a file from the list to view it.';
            xmlFiles.forEach((file, index) => {
                const listItem = document.createElement('li');
                listItem.textContent = file.name;
                listItem.className = 'file-list-item';
                listItem.dataset.index = index;
                listItem.addEventListener('click', handleFileClick);
                fileList.appendChild(listItem);
            });
        } else {
            initialMessage.textContent = 'No XML files found in the selected directory.';
        }
    }

    function handleFileClick(event) {
        // Highlight selected file
        document.querySelectorAll('.file-list-item').forEach(item => item.classList.remove('selected'));
        event.target.classList.add('selected');

        const fileIndex = event.target.dataset.index;
        const file = xmlFiles[fileIndex];
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const xmlContent = e.target.result;
            generateViewerFromXML(xmlContent, file.name);
        };
        reader.readAsText(file);
    }

    function generateViewerFromXML(xmlString, fileName) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");

            // Check for parsing errors
            const parseError = xmlDoc.querySelector("parsererror");
            if (parseError) {
                console.error("Error parsing XML:", parseError);
                alert("Error parsing XML file. Check console for details.");
                return;
            }
            
            // --- 1. Extract Screenshot ---
            const imageElem = xmlDoc.querySelector('image[type="PNG"]');
            const screenshotContainer = document.getElementById('screenshotContainer');
            if (imageElem && imageElem.textContent) {
                screenshotContainer.innerHTML = `<img class='screenshot' src='data:image/png;base64,${imageElem.textContent.trim()}'>`;
            } else {
                screenshotContainer.innerHTML = "<p><i>No screenshot found.</i></p>";
            }

            // --- 2. Build HTML Tree ---
            const treeContainer = document.getElementById('treeContainer');
            const rootElement = xmlDoc.querySelector("element");
            if (rootElement) {
                const treeHtml = buildTreeHtmlJS(rootElement);
                treeContainer.innerHTML = `<ul class='tree'>${treeHtml}</ul>`;
            } else {
                treeContainer.innerHTML = "<p><i>No object structure found.</i></p>";
            }

            // --- 3. Update UI ---
            document.getElementById('screenshot-path').textContent = fileName;
            document.title = `Squish Snapshot Viewer - ${fileName}`;
            
            // Show viewer and hide initial message
            initialMessage.style.display = 'none';
            viewerContent.style.display = 'flex';

            // Reset properties view
            document.getElementById("props").innerHTML = 'Click a node in the tree to see its properties here.';
            
            // Re-initialize or update parts of the old script that depend on new content
            resetViewerState();

        } catch (e) {
            console.error("Failed to generate viewer:", e);
            alert("An error occurred while processing the file. Check console for details.");
        }
    }

    function buildTreeHtmlJS(node) {
        let properties = {};
        // Attributes
        for (const attr of node.attributes) {
            properties[attr.name] = attr.value;
        }

        // Child text nodes
        for (const child of node.children) {
            if (child.children.length === 0 && child.textContent) {
                 if (child.tagName === 'superclass') {
                    let classes = Array.from(child.querySelectorAll("class")).map(c => c.textContent).filter(Boolean);
                    if (classes.length > 0) properties["superclasses"] = classes.join(" > ");
                } else {
                    properties[child.tagName] = child.textContent.trim();
                }
            }
        }
        
        // Special handling for geometry
        const geomElem = node.querySelector("abstractProperties > geometry");
        if (geomElem) {
            for(const coord of ["x", "y", "width", "height"]) {
                const coordElem = geomElem.querySelector(coord);
                if (coordElem && coordElem.textContent) {
                    properties[`geometry_${coord}`] = coordElem.textContent;
                }
            }
        }
        
        // Special handling for visual properties
        const visualElem = node.querySelector("abstractProperties > visual");
        if (visualElem) {
            for (const attr of visualElem.attributes) {
                properties[`visual_${attr.name}`] = attr.value;
            }
        }

        // Special handling for properties
        const propsElem = node.querySelector("properties");
        if (propsElem) {
            for (const prop of propsElem.querySelectorAll("property")) {
                const propName = prop.getAttribute("name");
                const stringElem = prop.querySelector("string");
                if (propName) {
                    properties[propName] = stringElem && stringElem.textContent ? stringElem.textContent : "";
                }
            }
        }

        let label = properties.objectName || properties.simplifiedType || node.tagName;

        const dataProps = escapeHtml(JSON.stringify(properties));
        const xmlSnippet = new XMLSerializer().serializeToString(node);
        const dataXml = escapeHtml(xmlSnippet);

        let html = `<li>`;
        const children = Array.from(node.children).filter(c => c.tagName === 'children' || c.tagName === 'element');
        let childElements = [];
        if (children.length > 0 && children[0].tagName === 'children') {
            childElements = Array.from(children[0].children).filter(c => c.tagName === 'element');
        } else {
            childElements = children.filter(c => c.tagName === 'element');
        }

        if (childElements.length > 0) {
            html += `<span class="toggle">-</span><span class="node" data-props="${dataProps}" data-xml="${dataXml}">${escapeHtml(label)}</span>`;
            html += `<ul class="nested">`;
            childElements.forEach(child => {
                html += buildTreeHtmlJS(child);
            });
            html += `</ul>`;
        } else {
            html += `<span class="node" data-props="${dataProps}" data-xml="${dataXml}">${escapeHtml(label)}</span>`;
        }

        html += `</li>`;
        return html;
    }
    
    function resetViewerState() {
        currentSelectedNode = null;
        currentPropsData = null;
        currentContextNode = null;
        screenshotGeometry = null;
        // Clear any previous overlays
        const existingOverlay = document.getElementById('elementOverlay');
        if (existingOverlay) {
            existingOverlay.remove();
        }
    }

});

// --- End of New Logic ---


// --- Start of Original viewer_scripts.js (with modifications) ---

function filterTreeByPropertyValue() {
    var searchTerm = document.getElementById('propertyValueSearch').value.toLowerCase();
    var treeContainer = document.getElementById('treeContainer');
    var allNodes = treeContainer.querySelectorAll('li');

    var allSpans = treeContainer.querySelectorAll('.node');
    allSpans.forEach(function(span) {
        span.style.backgroundColor = '';
    });

    if (searchTerm === '') {
        allNodes.forEach(function(node) {
            node.style.display = '';
        });
        var allUls = treeContainer.querySelectorAll('ul');
        allUls.forEach(function(ul) {
            ul.style.display = '';
        });
        return;
    }
    allNodes.forEach(function(node) {
        node.style.display = 'none';
    });
    var nodeSpans = treeContainer.querySelectorAll('.node');
    nodeSpans.forEach(function(span) {
        var props = span.getAttribute('data-props') || '{}';
        try {
            var propsObj = JSON.parse(props);
            var found = false;
            for (var key in propsObj) {
                if (propsObj.hasOwnProperty(key)) {
                    var value = propsObj[key];
                    if (typeof value === 'string' && value.toLowerCase().includes(searchTerm)) {
                        found = true;
                        break;
                    }
                }
            }
            if (found) {
                span.style.backgroundColor = 'yellow';
                var current = span.closest('li');
                while (current) {
                    current.style.display = '';
                    var parentUl = current.parentElement;
                    if (parentUl && parentUl.tagName === 'UL') {
                        parentUl.style.display = '';
                        var parentLi = parentUl.parentElement;
                        if (parentLi && parentLi.tagName === 'LI') {
                            parentLi.style.display = '';
                            current = parentLi;
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }
            }
        } catch(e) {}
    });
}

function clearPropertyValueSearch() {
    var input = document.getElementById('propertyValueSearch');
    input.value = '';
    input.focus();
    filterTreeByPropertyValue();
    toggleClearButton('propertyValueSearch', 'clearPropertyValueSearch');
}

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\/]/g, '\$&');
}

function highlightText(text, searchTerms) {
    if (!searchTerms || searchTerms.length === 0) {
        return text;
    }
    searchTerms = searchTerms.filter(Boolean);
    if (searchTerms.length === 0) {
        return text;
    }
    var combinedRegex = searchTerms.map(term => '(' + escapeRegExp(term) + ')').join('|');
    var regex = new RegExp(combinedRegex, 'gi');
    return text.toString().replace(regex, '<mark>$&</mark>');
}

function formatPropertiesAsTable(propsStr, searchTerm, highlightTerms) {
    try {
        var props = JSON.parse(propsStr);
        if (typeof props !== 'object' || props === null) {
            return "<p>No properties available</p>";
        }
        
        searchTerm = searchTerm || "";
        
        var groups = {};
        var standalone = {};
        
        for (var key in props) {
            if (props.hasOwnProperty(key)) {
                var parts = key.split('_');
                if (parts.length > 1 && ['geometry', 'visual'].includes(parts[0])) {
                    var groupName = parts[0];
                    var propName = parts.slice(1).join('_');
                    if (!groups[groupName]) groups[groupName] = {};
                    groups[groupName][propName] = props[key];
                } else if (key === 'superclasses') {
                    if (!groups['superclasses']) groups['superclasses'] = {};
                    var classes = props[key].split(' > ');
                    for (var i = 0; i < classes.length; i++) {
                        groups['superclasses']['level_' + i] = classes[i];
                    }
                } else {
                    standalone[key] = props[key];
                }
            }
        }
        
        var sortColumn = document.getElementById('sortColumn').value;
        var sortDirection = document.getElementById('sortOrder').value;
        
        function sortKeys(obj) {
            var keys = Object.keys(obj);
            if (sortDirection === 'asc') {
                keys.sort();
            } else if (sortDirection === 'desc') {
                keys.sort().reverse();
            }
            return keys;
        }
        
        var table = "<table class='props-table'>";
        table += "<thead><tr>";
        table += "<th class='" + (sortColumn === 'Property' && sortDirection !== 'none' ? 'sort-' + sortDirection : '') + "'>Property</th>";
        table += "<th class='" + (sortColumn === 'Value' && sortDirection !== 'none' ? 'sort-' + sortDirection : '') + "'>Value</th>";
        table += "</tr></thead><tbody>";
        
        var standaloneKeys = sortKeys(standalone);
        for (var i = 0; i < standaloneKeys.length; i++) {
            var key = standaloneKeys[i];
            var value = standalone[key];
            if (value === null || value === undefined) value = "";
            
            if (searchTerm === "" || 
                key.toLowerCase().includes(searchTerm) || 
                value.toString().toLowerCase().includes(searchTerm)) {
                var highlightedKey = highlightText(key, highlightTerms);
                var highlightedValue = highlightText(value, highlightTerms);
                table += "<tr><td>" + highlightedKey + "</td><td>" + highlightedValue + "</td></tr>";
            }
        }
        
        var groupKeys = sortKeys(groups);
        for (var i = 0; i < groupKeys.length; i++) {
            var groupName = groupKeys[i];
            var groupHasMatches = false;
            var groupContent = "";
            
            var groupPropKeys = sortKeys(groups[groupName]);
            for (var j = 0; j < groupPropKeys.length; j++) {
                var propName = groupPropKeys[j];
                var value = groups[groupName][propName];
                if (value === null || value === undefined) value = "";
                var displayName = propName.replace('level_', 'inheritance_');
                
                if (searchTerm === "" || 
                    groupName.toLowerCase().includes(searchTerm) ||
                    displayName.toLowerCase().includes(searchTerm) || 
                    value.toString().toLowerCase().includes(searchTerm)) {
                    var highlightedDisplayName = highlightText(displayName, highlightTerms);
                    var highlightedValue = highlightText(value, highlightTerms);
                    groupContent += "<tr class='group-item group-" + groupName + "'><td>&nbsp;&nbsp;&nbsp;&nbsp;" + highlightedDisplayName + "</td><td>" + highlightedValue + "</td></tr>";
                    groupHasMatches = true;
                }
            }
            
            if (groupHasMatches) {
                var highlightedGroupName = highlightText(groupName, highlightTerms);
                table += "<tr class='group-header' data-group='" + groupName + "'><td colspan='2'><span class='toggle'>-</span><strong>" + highlightedGroupName + "</strong></td></tr>";
                table += groupContent;
            }
        }
        
        table += "</tbody></table>";
        
        setTimeout(function() {
            var tableRows = document.querySelectorAll('.props-table tr:not(.group-header)');
            tableRows.forEach(function(row) {
                row.addEventListener('click', function() {
                    document.querySelectorAll('.props-table tr').forEach(function(r) {
                        r.classList.remove('selected');
                    });
                    this.classList.add('selected');
                });
            });

            var groupHeaders = document.querySelectorAll('.props-table .group-header');
            groupHeaders.forEach(function(header) {
                header.addEventListener('click', function() {
                    var groupName = this.dataset.group;
                    var groupItems = document.querySelectorAll('.props-table .group-' + groupName);
                    var toggle = this.querySelector('.toggle');
                    groupItems.forEach(function(item) {
                        item.style.display = item.style.display === 'none' ? '' : 'none';
                    });
                    toggle.textContent = toggle.textContent === '-' ? '+' : '-';
                });
            });
        }, 10);
        
        return table;
    } catch(e) {
        console.error("Error formatting properties table", e);
        return "<p class='props'>" + propsStr + "</p>";
    }
}

var currentSelectedNode = null;
var currentPropsData = null;
var currentContextNode = null;
var currentContextPropName = null;
var currentContextPropValue = null;
var screenshotGeometry = null;

function refreshProperties() {
    if (currentSelectedNode) {
        var props = currentSelectedNode.getAttribute("data-props") || "{}";
        currentPropsData = props;
        filterAndDisplayProperties();
        updateElementOverlay();
    }
}

function updateElementOverlay() {
    var existingOverlay = document.getElementById('elementOverlay');
    if (existingOverlay) {
        existingOverlay.remove();
    }
    
    if (!currentSelectedNode) return; 
    
    var props = currentSelectedNode.getAttribute("data-props") || "{}";
    try {
        var propsObj = JSON.parse(props);
        
        var elemX = propsObj['geometry_x'];
        var elemY = propsObj['geometry_y'];
        var elemWidth = propsObj['geometry_width'];
        var elemHeight = propsObj['geometry_height'];
        
        if (elemX !== undefined && elemY !== undefined && elemWidth !== undefined && elemHeight !== undefined) {
            if (!screenshotGeometry) {
                var allNodes = document.querySelectorAll('.node');
                for (var i = 0; i < allNodes.length; i++) {
                    var nodeProps = allNodes[i].getAttribute("data-props") || "{}";
                    try {
                        var nodePropsObj = JSON.parse(nodeProps);
                        if (nodePropsObj['geometry_x'] !== undefined) {
                            screenshotGeometry = {
                                x: parseInt(nodePropsObj['geometry_x']) || 0,
                                y: parseInt(nodePropsObj['geometry_y']) || 0
                            };
                            break;
                        }
                    } catch(e) {}
                }
                if (!screenshotGeometry) {
                    screenshotGeometry = {x: 0, y: 0};
                }
            }
            
            drawElementOverlay(
                parseInt(elemX) - screenshotGeometry.x,
                parseInt(elemY) - screenshotGeometry.y,
                parseInt(elemWidth),
                parseInt(elemHeight)
            );
        }
    } catch(e) {
        console.log('Error parsing properties for overlay:', e);
    }
}

function drawElementOverlay(x, y, width, height) {
    var screenshotImg = document.querySelector('.screenshot');
    var container = document.getElementById('screenshotContainer');
    
    if (!screenshotImg || !container) return;
    
    var imgRect = screenshotImg.getBoundingClientRect();
    var containerRect = container.getBoundingClientRect();
    
    var scaleX = imgRect.width / screenshotImg.naturalWidth;
    var scaleY = imgRect.height / screenshotImg.naturalHeight;
    
    var offsetX = imgRect.left - containerRect.left;
    var offsetY = imgRect.top - containerRect.top;

    var overlayX = (x * scaleX) + offsetX - 2;
    var overlayY = (y * scaleY) + offsetY - 2;
    var overlayWidth = width * scaleX;
    var overlayHeight = height * scaleY;
    
    var overlay = document.createElement('div');
    overlay.id = 'elementOverlay';
    overlay.className = 'element-overlay';
    overlay.style.left = overlayX + 'px';
    overlay.style.top = overlayY + 'px';
    overlay.style.width = overlayWidth + 'px';
    overlay.style.height = overlayHeight + 'px';
    
    container.appendChild(overlay);
}

function filterAndDisplayProperties() {
    if (!currentPropsData) return;
    
    var propsSearchTerm = document.getElementById('propsSearch').value.toLowerCase();
    var propertyValueSearchTerm = document.getElementById('propertyValueSearch').value.toLowerCase();

    var highlightTerms = [];
    if (propsSearchTerm) highlightTerms.push(propsSearchTerm);
    if (propertyValueSearchTerm) highlightTerms.push(propertyValueSearchTerm);

    var html = formatPropertiesAsTable(currentPropsData, propsSearchTerm, highlightTerms);
    document.getElementById("props").innerHTML = html;
}

function filterTree(nodesToDisplay = null) {
    var searchTerm = document.getElementById('treeSearch').value.toLowerCase();
    var treeContainer = document.getElementById('treeContainer');
    var showOnlyMatchesChecked = document.getElementById('showOnlyMatches').checked;

    var allSpans = treeContainer.querySelectorAll('.node');
    allSpans.forEach(function(span) {
        span.style.backgroundColor = '';
    });

    var allNodes = treeContainer.querySelectorAll('li');
    allNodes.forEach(function(node) {
        node.style.display = '';
    });
    var allUls = treeContainer.querySelectorAll('ul');
    allUls.forEach(function(ul) {
        ul.style.display = '';
    });

    var nodesToProcess = [];
    if (nodesToDisplay && nodesToDisplay.length > 0) {
        nodesToProcess = nodesToDisplay;
    } else if (searchTerm !== '') {
        var nodeSpans = treeContainer.querySelectorAll('.node');
        nodeSpans.forEach(function(span) {
            if (span.textContent.toLowerCase().includes(searchTerm)) {
                nodesToProcess.push(span);
            }
        });
    } else {
        return;
    }

    if (showOnlyMatchesChecked && (nodesToProcess.length > 0 || searchTerm !== '')) {
        allNodes.forEach(function(node) {
            node.style.display = 'none';
        });
    }

    nodesToProcess.forEach(function(nodeSpan) {
        nodeSpan.style.backgroundColor = 'yellow';
        var current = nodeSpan.closest('li');
        while (current) {
            current.style.display = '';
            var parentUl = current.parentElement;
            if (parentUl && parentUl.tagName === 'UL') {
                parentUl.style.display = '';
                var parentLi = parentUl.parentElement;
                if (parentLi && parentLi.tagName === 'LI') {
                    parentLi.style.display = '';
                    current = parentLi;
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    });
}

function toggleClearButton(inputId, buttonId) {
    var input = document.getElementById(inputId);
    var button = document.getElementById(buttonId);
    if (input.value.length > 0) {
        button.style.display = 'block';
    } else {
        button.style.display = 'none';
    }
}

function clearTreeSearch() {
    var input = document.getElementById('treeSearch');
    input.value = '';
    input.focus();
    filterTree();
    toggleClearButton('treeSearch', 'clearTreeSearch');
}

function clearPropsSearch() {
    var input = document.getElementById('propsSearch');
    input.value = '';
    input.focus();
    filterAndDisplayProperties();
    toggleClearButton('propsSearch', 'clearPropsSearch');
}

function copyToClipboard(type) {
    var contextMenuItem = event.target.closest('.context-menu-item');
    if (contextMenuItem && contextMenuItem.classList.contains('disabled-menu-item')) {
        return;
    }

    var textToCopy = "";

    if (type === 'realname' || type === 'class' || type === 'objectName') {
        if (currentContextNode) {
            var props = currentContextNode.getAttribute("data-props") || "{}";
            try {
                var textarea = document.createElement('textarea');
                textarea.innerHTML = props;
                var propsObj = JSON.parse(textarea.value);
                textToCopy = propsObj[type] || "";
            } catch(e) {
                textToCopy = "Property not found";
            }
        }
    } else if (type === 'copy-as-object') {
        if (currentContextNode) {
            var props = currentContextNode.getAttribute("data-props") || "{}";
            try {
                var textarea = document.createElement('textarea');
                textarea.innerHTML = props;
                var propsObj = JSON.parse(textarea.value);

                var objectName = propsObj['objectName'];
                var namePart = objectName ? `"${objectName}"` : "None";
                var simplifiedType = propsObj['simplifiedType'] || '';
                
                var extraProps = {};
                var realnameAttrs = {};
                if (propsObj['realname']) {
                    realnameAttrs = parseRealnameAttributes(propsObj['realname'], attributeWhitelist);
                    extraProps = Object.assign(extraProps, realnameAttrs);
                }

                for (var key in propsObj) {
                    if (attributeWhitelist.includes(key) && propsObj[key] !== '' && !realnameAttrs.hasOwnProperty(key)) {
                        extraProps[key] = propsObj[key];
                    }
                }

                var extraPropsString = Object.entries(extraProps).map(([key, value]) => `"${key}": "${value}"`).join(', ');

                textToCopy = `BasePage.element(BasePage.quick_view, ${namePart}, "${simplifiedType}"`;
                if (extraPropsString) {
                    textToCopy += ` , **{${extraPropsString}}`;
                }
                textToCopy += `)`;

            } catch(e) {
                textToCopy = "Failed to generate object string";
            }
        }
    } else if (type === 'propName') {
        textToCopy = currentContextPropName || "";
    } else if (type === 'propValue') {
        textToCopy = currentContextPropValue || "";
    }

    function showToast(message) {
        var feedback = document.createElement('div');
        feedback.textContent = message;
        feedback.style.cssText = 'position:fixed;top:20px;right:20px;background:#2c3e50;color:white;padding:10px 20px;border-radius:4px;z-index:10000;font-family:Arial,sans-serif;font-size:14px;';
        document.body.appendChild(feedback);
        setTimeout(function() { document.body.removeChild(feedback); }, 2500);
    }

    if (textToCopy) {
        navigator.clipboard.writeText(textToCopy).then(function() {
            var shortText = textToCopy.length > 50 ? textToCopy.substring(0, 47) + '...' : textToCopy;
            showToast('Copied "' + shortText + '" to clipboard.');
        }).catch(function(err) {
            console.error('Failed to copy: ', err);
            var textArea = document.createElement('textarea');
            textArea.value = textToCopy;
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                var shortText = textToCopy.length > 50 ? textToCopy.substring(0, 47) + '...' : textToCopy;
                showToast('Copied "' + shortText + '" to clipboard.');
            } catch (copyErr) {
                showToast('Failed to copy.');
            }
            document.body.removeChild(textArea);
        });
    }
    
    hideContextMenus();
}

function hideContextMenus() {
    document.getElementById('treeContextMenu').style.display = 'none';
    document.getElementById('propsContextMenu').style.display = 'none';
}

function showTreeContextMenu(e, node) {
    e.preventDefault();
    currentContextNode = node;

    var props = currentContextNode.getAttribute("data-props") || "{}";
    try {
        var propsObj = JSON.parse(props);
        var realname = propsObj['realname'] || "";

        var copyAsObjectItem = document.querySelector('[data-type="copy-as-object"]');
        var braceCount = (realname.match(/{/g) || []).length;

        if (braceCount <= 1 || (braceCount === 2 && realname.includes("type='QuickView'"))) {
            copyAsObjectItem.classList.remove('disabled-menu-item');
        } else {
            copyAsObjectItem.classList.add('disabled-menu-item');
        }
    } catch(e) {
        var copyAsObjectItem = document.querySelector('[data-type="copy-as-object"]');
        copyAsObjectItem.classList.add('disabled-menu-item');
    }

    var menu = document.getElementById('treeContextMenu');
    menu.style.display = 'block';
    menu.style.left = e.pageX + 'px';
    menu.style.top = e.pageY + 'px';
}

function showPropsContextMenu(e, propName, propValue) {
    e.preventDefault();
    currentContextPropName = propName;
    currentContextPropValue = propValue;
    var menu = document.getElementById('propsContextMenu');
    menu.style.display = 'block';
    menu.style.left = e.pageX + 'px';
    menu.style.top = e.pageY + 'px';
}

function escapeHtml(unsafe) {
    if (unsafe === null || unsafe === undefined) return "";
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

function parseRealnameAttributes(realnameString, whitelist) {
    var attributes = {};
    whitelist.forEach(function(key) {
        var regex = new RegExp(key + "='([^']*)'");
        var match = realnameString.match(regex);
        if (match) {
            attributes[key] = match[1];
        }
    });
    return attributes;
}

function findElementsByCoordinates(x, y) {
    var screenshotImg = document.querySelector('.screenshot');
    if (!screenshotImg) return;

    if (!screenshotGeometry) {
        var allNodes = document.querySelectorAll('.node');
        for (var i = 0; i < allNodes.length; i++) {
            var nodeProps = allNodes[i].getAttribute("data-props") || "{}";
            try {
                var nodePropsObj = JSON.parse(nodeProps);
                if (nodePropsObj['geometry_x'] !== undefined) {
                    screenshotGeometry = {
                        x: parseInt(nodePropsObj['geometry_x']) || 0,
                        y: parseInt(nodePropsObj['geometry_y']) || 0
                    };
                    break;
                }
            } catch(e) {}
        }
        if (!screenshotGeometry) {
            screenshotGeometry = {x: 0, y: 0};
        }
    }

    var scaleX = screenshotImg.naturalWidth / screenshotImg.width;
    var scaleY = screenshotImg.naturalHeight / screenshotImg.height;

    var clickX = (x * scaleX) + screenshotGeometry.x;
    var clickY = (y * scaleY) + screenshotGeometry.y;

    var allNodes = document.querySelectorAll('.node');
    allNodes.forEach(function(node) {
        node.classList.remove('highlight');
    });

    var matchingNodes = [];
    allNodes.forEach(function(node) {
        var props = node.getAttribute('data-props') || '{}';
        try {
            var propsObj = JSON.parse(props);

            var elemX = parseInt(propsObj['geometry_x']);
            var elemY = parseInt(propsObj['geometry_y']);
            var elemWidth = parseInt(propsObj['geometry_width']);
            var elemHeight = parseInt(propsObj['geometry_height']);

            if (!isNaN(elemX) && !isNaN(elemY) && !isNaN(elemWidth) && !isNaN(elemHeight)) {
                if (clickX >= elemX && clickX <= elemX + elemWidth &&
                    clickY >= elemY && clickY <= elemY + elemHeight) {
                    matchingNodes.push({node: node, width: elemWidth, height: elemHeight});
                }
            }
        } catch (e) {}
    });

    if (matchingNodes.length > 0) {
        var smallestNode = matchingNodes.reduce(function(prev, curr) {
            var prevArea = prev.width * prev.height;
            var currArea = curr.width * curr.height;
            return (prevArea < currArea) ? prev : curr;
        });

        document.querySelectorAll(".node").forEach(n => n.classList.remove("selected"));
        smallestNode.node.classList.add("selected");
        currentSelectedNode = smallestNode.node;
        var props = currentSelectedNode.getAttribute("data-props") || "{}";
        currentPropsData = props;
        filterAndDisplayProperties();
        updateElementOverlay();

        matchingNodes.forEach(function(match) {
            match.node.classList.add('highlight');
        });
        filterTree(matchingNodes.map(m => m.node));
    } else {
        filterTree([]);
    }
}

document.addEventListener("DOMContentLoaded", function() {
    document.getElementById("treeSearch").addEventListener("input", function() {
        filterTree();
        toggleClearButton('treeSearch', 'clearTreeSearch');
        if (document.getElementById('propertyValueSearch').value.length > 0) {
            filterTreeByPropertyValue();
        }
    });
    document.getElementById("propsSearch").addEventListener("input", function() {
        filterAndDisplayProperties();
        toggleClearButton('propsSearch', 'clearPropsSearch');
    });

    var showOnlyMatchesCheckbox = document.getElementById('showOnlyMatches');
    if (showOnlyMatchesCheckbox) {
        showOnlyMatchesCheckbox.addEventListener('change', function() {
            filterTree();
        });
    }

    var screenshotContainer = document.getElementById('screenshotContainer');
    if (screenshotContainer) {
        screenshotContainer.addEventListener('click', function(e) {
            var screenshotImg = document.querySelector('.screenshot');
            if (!screenshotImg) return;

            var rect = screenshotImg.getBoundingClientRect();
            var x = e.clientX - rect.left;
            var y = e.clientY - rect.top;

            findElementsByCoordinates(x, y);
        });
    }

    document.addEventListener('click', function(e) {
        if (e.target.classList.contains("node")) {
            document.querySelectorAll(".node").forEach(n => n.classList.remove("selected"));
            e.target.classList.add("selected");
            currentSelectedNode = e.target;
            var props = e.target.getAttribute("data-props") || "{}";
            currentPropsData = props;
            filterAndDisplayProperties();
            updateElementOverlay();
        }

        var contextMenuItem = e.target.closest('.context-menu-item');
        if (contextMenuItem) {
            const type = contextMenuItem.getAttribute('data-type');
            if (type) {
                copyToClipboard(type);
            }
        } else if (!e.target.closest('.context-menu')) {
            hideContextMenus();
        }

        if (e.target.classList.contains('toggle')) {
            var nested = e.target.parentElement.querySelector('.nested');
            if (nested) {
                nested.classList.toggle('collapsed');
                e.target.textContent = nested.classList.contains('collapsed') ? '+' : '-';
            }
        }
    });

    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        if (e.target.classList.contains('node')) {
            showTreeContextMenu(e, e.target);
        } else {
            var targetCell = e.target.closest('.props-table td');
            if (targetCell) {
                var row = targetCell.parentElement;
                if (row.cells.length === 2) {
                    var propName = row.cells[0].textContent.trim();
                    var propValue = row.cells[1].textContent.trim();
                    showPropsContextMenu(e, propName, propValue);
                }
            }
        }
    });

    document.getElementById('props').addEventListener('click', function(e) {
        var th = e.target.closest('th');
        if (th) {
            var columnIndex = th.cellIndex;
            var newSortColumn = columnIndex === 0 ? 'Property' : 'Value';
            var sortColumnDropdown = document.getElementById('sortColumn');
            var sortOrderDropdown = document.getElementById('sortOrder');
            
            if (newSortColumn === sortColumnDropdown.value) {
                if (sortOrderDropdown.value === 'asc') {
                    sortOrderDropdown.value = 'desc';
                } else if (sortOrderDropdown.value === 'desc') {
                    sortOrderDropdown.value = 'none';
                } else {
                    sortOrderDropdown.value = 'asc';
                }
            } else {
                sortColumnDropdown.value = newSortColumn;
                sortOrderDropdown.value = 'asc';
            }
            
            refreshProperties();
        }
    });
});

</script>

</body>
</html>